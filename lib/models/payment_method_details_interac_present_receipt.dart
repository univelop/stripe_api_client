// ignore_for_file: type=lint
import 'package:microsoft_kiota_abstractions/microsoft_kiota_abstractions.dart';
import './payment_method_details_interac_present_receipt_account_type.dart';

/// auto generated
class PaymentMethodDetailsInteracPresentReceipt
    implements AdditionalDataHolder, Parsable {
  ///  The type of account being debited or credited
  PaymentMethodDetailsInteracPresentReceiptAccountType? accountType;

  ///  Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
  @override
  Map<String, Object?> additionalData;

  ///  The Application Cryptogram, a unique value generated by the card to authenticate the transaction with issuers.
  String? applicationCryptogram;

  ///  The Application Identifier (AID) on the card used to determine which networks are eligible to process the transaction. Referenced from EMV tag 9F12, data encoded on the card's chip.
  String? applicationPreferredName;

  ///  Identifier for this transaction.
  String? authorizationCode;

  ///  EMV tag 8A. A code returned by the card issuer.
  String? authorizationResponseCode;

  ///  Describes the method used by the cardholder to verify ownership of the card. One of the following: `approval`, `failure`, `none`, `offline_pin`, `offline_pin_and_signature`, `online_pin`, or `signature`.
  String? cardholderVerificationMethod;

  ///  Similar to the application_preferred_name, identifying the applications (AIDs) available on the card. Referenced from EMV tag 84.
  String? dedicatedFileName;

  ///  A 5-byte string that records the checks and validations that occur between the card and the terminal. These checks determine how the terminal processes the transaction and what risk tolerance is acceptable. Referenced from EMV Tag 95.
  String? terminalVerificationResults;

  ///  An indication of which steps were completed during the card read process. Referenced from EMV Tag 9B.
  String? transactionStatusInformation;

  /// Instantiates a new [PaymentMethodDetailsInteracPresentReceipt] and sets the default values.
  PaymentMethodDetailsInteracPresentReceipt() : additionalData = {};

  /// Creates a new instance of the appropriate class based on discriminator value
  ///  [parseNode] The parse node to use to read the discriminator value and create the object
  static PaymentMethodDetailsInteracPresentReceipt createFromDiscriminatorValue(
      ParseNode parseNode) {
    return PaymentMethodDetailsInteracPresentReceipt();
  }

  /// The deserialization information for the current model
  @override
  Map<String, void Function(ParseNode)> getFieldDeserializers() {
    var deserializerMap = <String, void Function(ParseNode)>{};
    deserializerMap['account_type'] = (node) => accountType =
        node.getEnumValue<PaymentMethodDetailsInteracPresentReceiptAccountType>(
            (stringValue) =>
                PaymentMethodDetailsInteracPresentReceiptAccountType.values
                    .where((enumVal) => enumVal.value == stringValue)
                    .firstOrNull);
    deserializerMap['application_cryptogram'] =
        (node) => applicationCryptogram = node.getStringValue();
    deserializerMap['application_preferred_name'] =
        (node) => applicationPreferredName = node.getStringValue();
    deserializerMap['authorization_code'] =
        (node) => authorizationCode = node.getStringValue();
    deserializerMap['authorization_response_code'] =
        (node) => authorizationResponseCode = node.getStringValue();
    deserializerMap['cardholder_verification_method'] =
        (node) => cardholderVerificationMethod = node.getStringValue();
    deserializerMap['dedicated_file_name'] =
        (node) => dedicatedFileName = node.getStringValue();
    deserializerMap['terminal_verification_results'] =
        (node) => terminalVerificationResults = node.getStringValue();
    deserializerMap['transaction_status_information'] =
        (node) => transactionStatusInformation = node.getStringValue();
    return deserializerMap;
  }

  /// Serializes information the current object
  ///  [writer] Serialization writer to use to serialize this model
  @override
  void serialize(SerializationWriter writer) {
    writer.writeEnumValue<PaymentMethodDetailsInteracPresentReceiptAccountType>(
        'account_type', accountType, (e) => e?.value);
    writer.writeStringValue('application_cryptogram', applicationCryptogram);
    writer.writeStringValue(
        'application_preferred_name', applicationPreferredName);
    writer.writeStringValue('authorization_code', authorizationCode);
    writer.writeStringValue(
        'authorization_response_code', authorizationResponseCode);
    writer.writeStringValue(
        'cardholder_verification_method', cardholderVerificationMethod);
    writer.writeStringValue('dedicated_file_name', dedicatedFileName);
    writer.writeStringValue(
        'terminal_verification_results', terminalVerificationResults);
    writer.writeStringValue(
        'transaction_status_information', transactionStatusInformation);
    writer.writeAdditionalData(additionalData);
  }
}
